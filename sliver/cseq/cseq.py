#!/usr/bin/env python2
""" CSeq C Program Analysis Framework 
	command-line front-end

    Copyright (c) 2014-2018, Omar Inverso
"""
from __future__ import print_function

FRAMEWORK_VERSION = 'CSeq-1.5-2018.04.22'   # CSeq 1.5 Release - experiments with parallel analysis
#FRAMEWORK_VERSION = 'CSeq-1.4-2017.02.27'  # start porting to python3 
#FRAMEWORK_VERSION = 'CSeq-1.3-2016.12.15'
#FRAMEWORK_VERSION = 'CSeq-1.3-2016.11.01'
#FRAMEWORK_VERSION = 'CSeq-1.2-2016.09.24'
#FRAMEWORK_VERSION = 'CSeq-1.2-2016.05.05'  # CSeq 1.2 student's coursework with transformation examples
#FRAMEWORK_VERSION = 'CSeq-1.1-2016.05.03'  # CSeq 1.1
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.07.16'  # CSeq 1.0 Release - ASE2015
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.07.09'
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.06.24'
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.05.05'
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.01.22'
#FRAMEWORK_VERSION = 'CSeq-1.0-2015.01.07'
#FRAMEWORK_VERSION = 'CSeq-1.0-2014.12.24'  # CSeq 1.0beta
#FRAMEWORK_VERSION = 'CSeq-2014.09.27'      # CSeq-Lazy-0.6: newseq-0.6a, newseq-0.6c, SVCOMP15
#FRAMEWORK_VERSION = 'CSeq-2014.06.02'
#FRAMEWORK_VERSION = 'CSeq-2014.02.28'
"""
Changelog:
	2016.12.05  new debug option to show linemap
	2016.11.01  improved usage screen
	2016.09.24  improved module error output
	2016.05.03  debug options
	2015.06.23  major work on modularization (module parameters,front-end output depending on the configuration)
	2015.05.05  output header with translation detail to replicate experiments
	2015.01.18  minor bugfixing in reading module chains
	2015.01.07  fixing default parameters assignments
	2014.12.09  new CSeq framework organisation
	2014.09.27  moved all code-sanitising to merger stage (merger.py).
	2014.09.22  use strings rather than temporary files before merging (faster)
	2014.09.22  moved thread_local workaround to merging stage (merger.py)
	2014.06.02  introduced specific  module.ModuleError  exception for detailed error handling
	2014.02.28  major code refactory
	            error details from module->module transforms incl. source snippet
	            uniform module importing and handling through one main for loop

TODO:
	- merger's linemapping should also track the input filename

	- handle multiple command-line parameters,
	  for example -I firstpath -I secondpath,
	  also -i firstsourcefile.c -i secondsourcefile.c

"""
import exceptions, getopt, glob, importlib, inspect, os, os.path, re, shutil, sys, time, traceback
from time import gmtime, strftime
import pycparser
from pycparser.plyparser import ParseError
import core.config, core.merger, core.module, core.parser, core.utils


class cseqenv:	
	cmdline = None      # full command-line
	opts = None         # command-line option-value pairs, e.g. (--input, 'file.c')
	args = None         # 
	
	params = []         # additional front-end input parameters
	paramIDs = []       # parameters ID only
	paramvalues = {}    # param values indexed by param ID

	debug = False       #
	showsymbols = False # 
	showast = False     #
	shownodes = False   #
	showlinemap = False #

	chainfile = None    # file with the sequence of modules to execute

	inputfile = None    # input source file to process
	includepath = None  # #include path (for source merging)
	outputfile = None   # TODO not implemented yet

	modules = []        # modules (each performing a single code trasformation)
	transforms = 0      # no. of modules executed so far

	maps = []
	lastlinenoinlastmodule = 0
	outputtofiles = []    # map from merged sources (= Merger's output) to original source file


def moduleparamusage(p):
	abc = "--%s" % (p.id)
	abc += " <%s>" % p.datatype if p.datatype else ''

	opt = 'optional' if p.optional else ''
	opt += ', ' if p.optional and p.default else ''
	opt += 'default:%s%s%s' % (core.utils.colors.HIGHLIGHT,p.default,core.utils.colors.NO) if p.default else ''
	opt = '(%s)' % opt if len(opt) > 0 else opt

	desc = ('\n    '+' '*26).join([l for l in p.description.split('\n')]) # multiline description

	return "%-26s %s %s" % (abc, desc, opt)


def usage(cmd, errormsg, showhelp=True, detail=False):
	'''
		long help (-H) provides the list of all input and output parameters
		for each module.

		short help (-h) provides only those input parameters
	    that must be provided in the command-line

	    (i.e. for each module the ones not generated by any of the previous 
	    modules in the configuration) 
	'''

	if showhelp:
		##configs = ''
		config = core.utils.extractparamvalue(cseqenv.cmdline, '-l','--load', core.config.defaultchain)
		currentconfig = core.config.defaultchain if config == core.config.defaultchain else config
		currentconfig = core.utils.colors.HIGHLIGHT+currentconfig+core.utils.colors.NO
		defaultorcurrent = 'default' if config == core.config.defaultchain else 'currently'

		print("")
		print("                  C  S e q   ")
		print("                              1 . 5")
		print("")
		print("Usage: ")
		print("")
		print("   %s -h [-l <config>]" % cmd)
		print("   %s -i <input.c> [options]" % cmd)
		print("")
		print(" configuration options: ")
		print("   -l, --load=<file>           configuration to use (%s:%s)" % (defaultorcurrent,currentconfig))
		print("   -L, --list-chains           show available configurations")
		print("")
		print(" input options:")
		print("   -i<file>, --input=<file>    input filename")
		print("   -I<path>, --include=<path>  include search path (use : as a separator) (default:%s./%s)" % (core.utils.colors.HIGHLIGHT,core.utils.colors.NO))
		print("")

		# Module-specific params for the given chain (or for the default one)
		print(" options:")

		outputparamssofar = []   # used to check which module input params are front-end input
		inputparamssofar = []

		for m in cseqenv.modules:
			if detail:
				print("  [%s]" % m.getname())
				if len(m.inputparamdefs) == len(m.outputparamdefs) == 0: print('')

			try:
				if detail:
					if len(m.inputparamdefs) > 0: print("     input:")

				for p in m.inputparamdefs:
					if (p.id not in [q.id for q in outputparamssofar] and
					p.id not in [q.id for q in inputparamssofar]):
						inputparamssofar.append(p)
						print('   '+moduleparamusage(p))
					elif detail:
						print('  ('+moduleparamusage(p)+')')

				if detail and len(m.inputparamdefs) > 0: print('')

				if detail:
					if len(m.outputparamdefs) > 0: print("     output:")

				for p in m.outputparamdefs:
					outputparamssofar.append(p)
					if detail:
						abc = "--%s" % (p.id)
						print("   %-26s %s" % (abc, p.description))

				if detail and len(m.outputparamdefs) > 0: print('')

			except Exception as e:
				print("Module error '%s':\n%s.\n" % (m.getname(), str(e)))
				traceback.print_exc(file=sys.stdout)
				sys.exit(1)

		print("")
		print(" debugging options: ")
		print("   -D, --debug                 dump (in:%s./%s/%s) input and output for each module" % (core.utils.colors.HIGHLIGHT,core.config.debugpath,core.utils.colors.NO))
		print("   -S, --showsymbols           show symbol table and exit")
		print("   -A, --showast               show abstract syntax tree and exit")
		print("   -M, --showlinemap           show linemap at the end of the output")
		#print "   -N, --shownodes             show ...")
		print("")
		print(" other options: ")
		print("   -h, --help                  show help")
		print("   -H, --detailedhelp          show detailed configuration-specific help")
		print("   -v, --version               show version number")
		print("")

	if errormsg:
		print(errormsg + '\n')
		sys.exit(1)

	sys.exit(0)


def listmodulechains():
	list = ''
	for filename in glob.glob('modules/*.chain'): list += filename[len('modules/'):-len('.chain')] + '\n'
	if list.endswith(', '): list = list[:-2]
	return list


def _showfullmapback():
	# Note: since the same input line may correspond to
	#       multiple lines in the final output,
	#       the tracing has to be done backwards.
	#
	lastmodule = len(cseqenv.maps)
	nextkey = 0
	inputfile = ''

	additionalspace = 4
	symbolspace = '.'

	for lineno in range(1,cseqenv.lastlinenoinlastmodule):
		lastmodule = len(cseqenv.maps)
		nextkey = 0
		inputfile = ''

		if cseqenv.maps[len(cseqenv.maps)-1].has_key(lineno):
			firstkey = nextkey = lastkey = lineno

			printfirstkey = symbolspace*(additionalspace+len(str(max(cseqenv.maps[len(cseqenv.maps)-1]))) - len(str(firstkey)))+str(firstkey)

			buff = ''
			buff +="%s" % printfirstkey

			for modno in reversed(range(0,lastmodule)):
				if nextkey in cseqenv.maps[modno] and nextkey != 0:
					lastkey = nextkey
					nextkey = cseqenv.maps[modno][nextkey]

					printnextkey = symbolspace*(additionalspace+len(str(max(cseqenv.maps[modno]))) - len(str(nextkey)))+str(nextkey)

					buff+="%s" % printnextkey
				else:
					nextkey = 0

				if modno == 0 and lastkey in cseqenv.outputtofiles:
					inputfile = cseqenv.outputtofiles[lastkey]
					buff +=" %s" %inputfile


		if not buff.endswith('_fake_typedefs.h') and (buff.endswith('.c') or buff.endswith('.h')): print(buff)


def main():
	'''
	# List all pycparser's AST visit_xyz methods
	# (any of them can be overridden in a module)
	#
	k = core.parser.Parser()
	methods = inspect.getmembers(k, predicate=inspect.ismethod)

	for m in methods:
		if m[0].startswith('visit_'): print m[0]

	sys.exit(1)
	'''
	## pkg_resources.get_distribution("pycparserext").version 2015.1
	## pkg_resources.get_distribution("pycparser").version    2.14

	'''                   '''
	''' I. Initialisation '''
	'''                   '''
	cseqenv.cmdline = sys.argv
	cseqenv.starttime = time.time()    # save wall time

	# Extract the configuration from the command-line or set it to the default.
	cseqenv.chainname = core.utils.extractparamvalue(cseqenv.cmdline, '-l','--load', core.config.defaultchain)
	cseqenv.chainfile = 'modules/%s.chain' % core.utils.extractparamvalue(cseqenv.cmdline, '-l','--load', core.config.defaultchain)

	if not core.utils.fileExists(cseqenv.chainfile):
		usage(cseqenv.cmdline[0], 'error: unable to open configuration file (%s)' % cseqenv.chainfile, showhelp=False)

	# Import all modules in the current configuration.
	for modulename in core.utils.printFile(cseqenv.chainfile).splitlines():
		if not modulename.startswith('#') and len(modulename) >= 1:
			modulename = modulename.strip()

			if '#' in modulename: modulename = modulename[:modulename.find('#')].strip()
			try:			
				mod = importlib.import_module('modules.'+modulename)
				cseqenv.modules.append(getattr(mod, modulename)())
			except ImportError as e:
				print("Unable to import module '%s',\nplease check installation.\n" % modulename)
				traceback.print_exc(file=sys.stdout)
				sys.exit(1)
			except AttributeError as e:
				print("Unable to load module '%s',\nplease check that the module filename,\nthe entry in the chain-file, and\nthe top-level classname in the module correctly match.\n" % modulename)
				traceback.print_exc(file=sys.stdout)
				sys.exit(1)
			except Exception as e:
				print("Unable to initialise module '%s':\n%s.\n" % (modulename, str(e)))
				traceback.print_exc(file=sys.stdout)
				sys.exit(1)

	# Init modules.
	for m in cseqenv.modules:
		try:
			if 'init' in dir(m):
				m.init()
		except Exception as e:
			print("Unable to initialise module '%s':\n%s.\n" % (m.getname(), str(e)))
			traceback.print_exc(file=sys.stdout)
			sys.exit(1)

	# Init module parameters.
	# 
	# Modules can have input and output parameters.
	# Any module input that is not the output of a previous module
	# is a front-end parameter
	# (it is displayed in the usage() screen, and
	#  it can be provided to the front-end in the command-line)
	inParams = []      # module-specific input parameters seen so far
	inParamIDs = []
	inparamvalues = {}

	outParams = []     # module-specific output parameters seen so far
	outParamIDs = []
	outparamvalues = {}

	for m in cseqenv.modules:
		try:
			for p in m.inputparamdefs:  # global input params seen so far
				if p.id not in inParamIDs:
					inParamIDs.append(p.id)
					inParams.append(p)

				# if the input param  p  is new and
				# no previous module generates it
				# (i.e., it is not an output param for any previous module)
				# then it needs to be a global (front-end) input
				if p.id not in outParamIDs:
					cseqenv.paramIDs.append(p.id)
					cseqenv.params.append(p)

			for p in m.outputparamdefs:  # output params seen so far
				if p.id not in outParamIDs:
					outParamIDs.append(p.id)
					outParams.append(p)
		except Exception as e:
			print("Unable to initialise module '%s':\n%s.\n" % (m.getname(), str(e)))
			traceback.print_exc(file=sys.stdout)
			sys.exit(1)

	'''                '''
	''' II. Parameters '''
	'''                '''
	# Parse command-line.
	try:
		shortargs = "hHdi:o:I:e:DSANMvl:C"
		longargs = [ "help", "detailedhelp", "detail", "input=", "output=", "include=",
		             "error-label=", 
		             "debug", "showsymbols", "showast", "shownodes", "showlinemap", "version", 
		             "load=", "listconfigs" ]    # <-- append module params here

		# add one command-line parameter for each module-specific parameter
		for p in cseqenv.params:
			longargs.append('%s%s' % (p.id, '' if p.isflag() else '='))

		cseqenv.opts, cseqenv.args = getopt.getopt(sys.argv[1:], shortargs, longargs)
	except getopt.GetoptError as err:
		usage(cseqenv.cmdline[0], 'error: ' +str(err))

	for o, a in cseqenv.opts:
		if o in ("-v", "--version"): print(FRAMEWORK_VERSION); return
		elif o in ("-h", "--help"): usage(cseqenv.cmdline[0],'')
		elif o in ("-H", "--detailedhelp"): usage(cseqenv.cmdline[0],'',detail=True)
		elif o in ("-l", "--load"): pass # handled beforehand, see above
		elif o in ("-C", "--listconfigs"): print(listmodulechains()); sys.exit(0)
		elif o in ("-D", "--debug"): cseqenv.debug = True
		elif o in ("-S", "--showsymbols"): cseqenv.showsymbols = True
		elif o in ("-A", "--showast"): cseqenv.showast = True
		elif o in ("-N", "--shownodes"): cseqenv.shownodes = True
		elif o in ("-M", "--showlinemap"): cseqenv.showlinemap = True
		elif o in ("-d", "--detail"): detail = True
		elif o in ("-i", "--input"): cseqenv.inputfile = a
		elif o in ("-o", "--output"): cseqenv.outputfile = a
		elif o in ("-I", "--include"): cseqenv.includepath = a
		else: # module-specific parameters
			cseqenv.paramvalues[o[2:]] = a

	# Basic parameter check.
	if not cseqenv.inputfile: usage(cseqenv.cmdline[0], 'error: input file name not specified.')
	if not core.utils.fileExists(cseqenv.inputfile): usage(cseqenv.cmdline[0], 'error: unable to open input file (%s)' % cseqenv.inputfile, showhelp=False)
	if not core.utils.fileExists(cseqenv.chainfile): usage(cseqenv.cmdline[0], 'error: unable to open module-chain file (%s)' % cseqenv.chainfile, showhelp=False)

	# All global parameters (calculated above) should be in the command-line.
	for p in cseqenv.params:
		if not p.optional and not p.default:
			usage(cseqenv.cmdline[0], 'error: %s (option --%s) not specified.' % (p.description, p.id))

	# Debug setup.
	cseqenv.debugpath = core.config.debugpath
	if not os.path.exists(core.config.debugpath): os.makedirs(core.config.debugpath)
	elif cseqenv.debug:
		shutil.rmtree(core.config.debugpath)
		os.makedirs(core.config.debugpath)

	'''              '''
	''' III. Merging '''
	'''              '''
	# Load the input file.
	input = core.utils.printFileRows(cseqenv.inputfile)

	# Merge all the source files into a single string.
	try:
		cseqenv.moduleID = 'merger'

		Merger = core.merger.Merger()
		Merger.loadfromstring(input,cseqenv)
		output = Merger.getoutput()
		cseqenv.transforms += 1

		if cseqenv.debug:
			core.utils.saveFile('%s/_00_input___merger.c' % core.config.debugpath, input)
			core.utils.saveFile('%s/_00_marked__merger.c' % cseqenv.debugpath,Merger.markedoutput)
			core.utils.saveFile('%s/_00_output__merger.c' % core.config.debugpath,output)
			core.utils.saveFile('%s/_00_linemap__merger.c' % core.config.debugpath,Merger.getlinenumbertable())

	except ParseError as e:
		print("Parse error (%s):\n" % str(e))
		print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output,Merger.getLineNo(e),Merger.getColumnNo(e),5,True), core.utils.colors.NO))
		sys.exit(1)
	except exceptions.SystemExit as e: # the module invoked sys.exit()
		sys.exit(1)
	except:
		traceback.print_exc(file=sys.stdout)
		sys.exit(1)

	if cseqenv.showsymbols:
		Parser = core.parser.Parser()
		Parser.loadfromstring(output)
		Parser.printsymbols()
		sys.exit(0)

	if cseqenv.showast:
		Parser = core.parser.Parser()
		Parser.loadfromstring(output)
		Parser.ast.show()
		sys.exit(0)

	'''
	if cseqenv.shownodes:
		Parser = core.parser.Parser()
		Parser.loadfromstring(output)
		Parser.shownodes()
		sys.exit(0)
	'''

	'''                    '''
	''' IV. Transformation '''
	'''                    '''
	cseqenv.maps.append(Merger.outputtoinput)
	cseqenv.outputtofiles = Merger.outputtofiles

	# Run all modules in a sequence
	for cseqenv.transforms, m in enumerate(cseqenv.modules):
		try:
			timeBefore = time.time()
			if cseqenv.debug:
				print("/* " + m.getname(), end='')

			m.initParams(cseqenv)
			m.loadfromstring(output, cseqenv)
			output = m.getoutput()

			if 'inputtooutput' in dir(m):   # linemapping only works on Translator (C-to-C) modules
				cseqenv.maps.append(m.outputtoinput)
				cseqenv.lastlinenoinlastmodule = m.output.count('\n')

			if cseqenv.debug:
				fileno = str(cseqenv.transforms+1).zfill(2)
				core.utils.saveFile('%s/_%s_input___%s.c' % (cseqenv.debugpath,fileno,m.getname()),m.input)
				core.utils.saveFile('%s/_%s_output__%s.c' % (cseqenv.debugpath,fileno,m.getname()),m.output)
				#core.utils.saveFile('_%s_%s.ast.c' % (cseqenv.transforms,moduleName),str(m.Parser.ast.show())) TODO
				#core.utils.saveFile('_%s_%s.symbols.c' % (cseqenv.transforms,moduleName),str(m.Parser.printsymbols())) TODO
				print("[%s] ok %0.2fs */" % (fileno, int(time.time()) - int(timeBefore)))

			if cseqenv.debug and 'markedoutput' in dir(m): # current module is a Translator
				core.utils.saveFile('%s/_%s_marked__%s.c' % (cseqenv.debugpath,fileno,m.getname()),m.markedoutput)
				core.utils.saveFile('%s/_%s_linemap__%s.c' % (cseqenv.debugpath,fileno,m.getname()),m.getlinenumbertable())

		except ParseError as e:
			print("Parse error (%s) while performing %s->%s:\n" % (str(e), cseqenv.modules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else '', cseqenv.modules[cseqenv.transforms].getname()))
			print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output, m.getLineNo(e), m.getColumnNo(e), 5, True), core.utils.colors.NO))
			sys.exit(1)
		except core.module.ModuleParamError as e:
			print("Module error (%s).\n" % (str(e)))
			sys.exit(1)
		except core.module.ModuleSyntaxError as e:
			tag = 'Error (module %s.py):' % cseqenv.modules[cseqenv.transforms].getname()
			print(tag) #print core.utils.colors.RED +tag+ core.utils.colors.NO,
			###print ('\n'+' '*taglen).join([l for l in str(e).split('\n')])
			print(str(e))
			print("\n%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(cseqenv.modules[cseqenv.transforms].input,cseqenv.modules[cseqenv.transforms].currentInputLineNumber,0,5,True), core.utils.colors.NO))
			sys.exit(1)
		except core.module.ModuleError as e:
			tag = 'Error (module %s.py):' % cseqenv.modules[cseqenv.transforms].getname()
			#print(tag) #print core.utils.colors.RED +tag+ core.utils.colors.NO,
			#taglen = len(tag)
			print(tag, end='') #print core.utils.colors.RED +tag+ core.utils.colors.NO,
			####print('\n'+' '*taglen).join([l for l in str(e)[1:-1].split('\n')])
			print(str(e))
			sys.exit(1)
		except KeyboardInterrupt as e:
			sys.exit(1)
		except ImportError as e:
			print("Import error (%s),\nplease re-install the tool.\n" % str(e))
			traceback.print_exc(file=sys.stdout)
			sys.exit(1)
		except Exception as e:
			print("Error while performing %s->%s:\n" % (cseqenv.modules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else '', cseqenv.modules[cseqenv.transforms].getname()))
			traceback.print_exc(file=sys.stdout)
			sys.exit(1)

	print(output)
	if cseqenv.showlinemap: _showfullmapback()

	sys.exit(1)

	######### print output  #print core.utils.strip(output)
	return


if __name__ == "__main__":
	main()







