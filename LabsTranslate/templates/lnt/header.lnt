module HEADER is

    {% for item in defines -%}
    function {{item.name}}:Int is return {{item.value}} end function
    {% endfor -%}

    type ID is X:Nat where X < MAXCOMPONENTS with "==", "!=" end type
    type IndexI is X:Nat where X < MAXKEYI with "==", "!=" end type
    type IndexL is X:Nat where X < MAXKEYL with "==", "!=" end type
    type PC is array [ 0 .. {{ MAXPC | minus: 1 }} ] of Nat end type

    function TUPLESTART(n:IndexL): IndexL is
        case n in
        {%- for i in tupleStart -%}
            {% unless forloop.first %}|{% endunless %} IndexL({{ forloop.index0 }}) -> return IndexL({{i}})
        {%- endfor -%}
            | any -> raise unexpected (* should never match *)
        end case
    end function

    function TUPLEEND(n:IndexL): IndexL is
        case n in
        {%- for i in tupleEnd -%}
            {% unless forloop.first %}|{% endunless %} IndexL({{ forloop.index0 }}) -> return IndexL({{i}})
        {%- endfor -%}
            | any -> raise unexpected (* should never match *)
        end case
    end function

    type Iface is array [ 0 .. {{ MAXKEYI | minus: 1 }} ] of Int with "get", "set" end type
    type LstigEntry is LstigEntry (value: Int, tstamp: Nat) with "get", "set" end type
    type Lstig is array [ 0 .. {{ MAXKEYI | minus: 1 }} ] of LstigEntry with "get", "set" end type

    --type Env is array [ 0 .. (*{{ MAXKEYE | minus : 1 }}*) ] of Int with "get", "set" end type


    type Pending is array [ 0 .. {{ MAXKEYL | minus: 1 }} ] of Bool with "get", "set" end type

    function length(p:Pending): Nat is
        var n, j:Nat in
            n := 0;
            for j := 0 while j < MAXKEYL by j := j + 1 loop
                if (p[j]) then n := n + 1 end if
            end loop;
            return n
        end var
    end function

    function empty(p:Pending): Bool is
        return (length(p) == 0)
    end function


    function empty(p:Pending): Bool is
        return (length(p) == 0)
    end function

    function insert(k: IndexL, p:Pending): Pending is
        var p1 : Pending in
            p1 := p;
            p1[Nat(k)] := true;
            return p1
        end var
    end function

    function remove(k: IndexL, p:Pending): Pending is
        var p1 : Pending in
            p1 := p;
            p1[Nat(k)] := false;
            return p1
        end var
    end function

    function member(k: IndexL, p:Pending): Bool is
        return p[Nat(k)]
    end function


    type Agent is agent(id: ID, I: Iface, L: Lstig, Zput: Pending, Zqry: Pending, init:Bool, pc:PC) with "get", "set" end type
    type Agents is array [ 0 .. {{ MAXCOMPONENTS | minus : 1 }} ] of Agent with "get", "set" end type
    type Sys is sys(agents: Agents, time: Nat (*, env: Env*)) with "get", "set" end type

    function emptyAgent: Agent is
        return Agent(ID(0), Iface(0), Lstig(LstigEntry(0, 0)), Pending(false), Pending(false), false, PC(0))
    end function

    function incr(x: Nat): Nat is 
        if x < 255 then return x + 1 else return 0 end if
    end function

    function link(a1: Agent, a2: Agent, key: Nat):Bool is
        {% for l in links %}
        {% unless forloop.first %}else {% endunless %}if ((key >= {{l.start}}) and (key <= {{l.end}})) then
            return {{l.link}}
        {% endfor %}
        end if
    end function

    process attr(in out a:Agent, key:Nat, val:Int) is 
        var Inew: Iface in 
            Inew := a.I;
            Inew[key] := val;
            a := a.{I => Inew}
        end var
    end process

    process lstig(in out a:Agent, key:Nat, val:Int, tstamp: Nat) is 
        var Lnew: Lstig in 
            Lnew := a.L;
            Lnew[key] := LstigEntry(val, tstamp);
            a := a.{L => Lnew, Zput => insert(TUPLESTART(IndexL(key)), a.Zput)}
        end var
    end process

    process propagate (in out sys:Sys) is
        var senderId:ID, key: IndexL, sender:Agent, agents:Agents in
            senderId := any ID where length(sys.agents[Nat(senderId)].Zput) > 0;
            agents := sys.agents;
            sender := agents[Nat(senderId)];
            key := any IndexL where member(key, sender.Zput);
            var j, k, t: Nat, L: Lstig, a:Agent in
                t := sys.time;
                for j := 0 while j < MAXCOMPONENTS by j := j + 1 loop
                    a := agents[j];
                    if a.init == false then INITAGENT(!?a, !?t) end if;

                    if (a.id != sender.id) and link(sender, a, Nat(key)) and 
                    (a.L[Nat(key)].tstamp < sender.L[Nat(key)].tstamp) then
                        L := a.L;
                        for k := Nat(key) while k <= Nat(TUPLEEND(key)) by k := k + 1 loop
                            L[k] := sender.L[k]
                        end loop;
                        agents[j] := a.{
                            L => L, 
                            Zput => insert(key, a.Zput),
                            Zqry => remove(key, a.Zqry)
                        }
                    end if
                end loop;
                agents[Nat(senderId)] := sender.{Zput => remove(key, sender.Zput)};
                sys := sys.{agents => agents, time => t}
            end var
        end var
    end process

    process confirm (in out sys:Sys) is
        var senderId:ID, key: IndexL, sender:Agent, agents:Agents in
            senderId := any ID where length(sys.agents[Nat(senderId)].Zqry) > 0;
            agents := sys.agents;
            sender := agents[Nat(senderId)];
            key := any IndexL where member(key, sender.Zqry);
            var j, k, t: Nat, L: Lstig, a:agent in
                t:=sys.time;
                for j := 0 while j < MAXCOMPONENTS by j := j + 1 loop
                    
                    a := agents[j];
                    if a.init == false then INITAGENT(!?a, !?t) end if;
                    
                    if (a.id != sender.id) and link(sender, a, Nat(key)) and
                    (a.L[Nat(key)].tstamp != sender.L[Nat(key)].tstamp) then 
                        a := a.{Zput => insert(key, a.Zput)};
                        if (a.L[Nat(key)].tstamp < sender.L[Nat(key)].tstamp) then
                            L := a.L;
                            for k := Nat(key) while k <= Nat(TUPLEEND(key)) by k := k + 1 loop
                                L[k] := sender.L[k]
                            end loop;
                            agents[j] := a.{L => L, Zqry => remove(key, a.Zqry)}
                        end if
                    end if
                end loop;
                agents[Nat(senderId)] := sender.{Zqry => remove(key, sender.Zqry)};
                sys := sys.{agents => agents, time => t}
            end var
        end var
    end process
